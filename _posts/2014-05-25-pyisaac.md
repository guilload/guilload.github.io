---
fullview: false
layout: post
title: FIXME!
permalink: pyisaac
categories: []
tags: []
---

I got pretty hammered at le [Point Éphémère](http://www.pointephemere.org/){:target="_blank"} last night. I’m currently lying in my bed, agonizing and recovering slowly from a harsh hangover sponsored by Jack Daniel's. In this context, what would you do to make your afternoon productive without leaving your sheets? I wish I answered "make love to my girlfriend" but since I don’t have one, coding seems like a reasonable second choice.

#### ISAAC: a fast cryptographically secure pseudorandom number generator

3 months ago, I discovered an algorithm called [ISAAC](http://burtleburtle.net/bob/rand/isaac.html){:target="_blank"} on [reddit](http://redd.it/1xl7yc){:target="_blank"}. ISAAC (Indirection, Shift, Accumulate, Add, and Count) is a cryptographically secure pseudorandom number generator ([CSPRNG](http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator){:target="_blank"}) designed in 1996 by [Bob Jenkins](http://burtleburtle.net/bob/){:target="_blank"} and produces 32-bit unsigned integer uniformly distributed, unbiased, and unpredictable (unless you know the seed, of course). Cycles are guaranteed to be at least 2<sup>40</sup> values long and they are 2<sup>8295</sup> values long on average. The generator runs fast and performs on average 18.75 machine cycles.

I've wanted to write my first Python extension for a long time and the short [C implementation](http://burtleburtle.net/bob/rand/isaacafa.html){:target="_blank"} combined with a simple API, solely composed of two functions, one for initializing the generator, one for generating random numbers, made ISAAC a great candidate for this task.


<!--more-->

#### Writing Python extensions is easy...

Given my inexperience, this post is not going to be an umpteenth tutorial about writing extensions, I would rather link you toward resources I found useful for this purpose. However, I would like to point out how easy it is to write extensions: Python’s documentation is clear, extensive and provides a great example that guides you step by step. In addition, the C API is simple and well documented too. This makes writing extensions a very pleasant experience. However, I haven't done it (yet) but from what I've [read](https://docs.python.org/3/howto/cporting.html){:target="_blank"}, writing modules compatible in both Python 2 and Python 3 looks tricky.

Here's what you need to get started:

*   [Extending and Embedding the Python Interpreter](https://docs.python.org/2/extending/extending.html){:target="_blank"}, Python's official documentation;
*   [Python Extension Programming with C](http://www.tutorialspoint.com/python/python_further_extensions.htm){:target="_blank"}, Tutorials Point;
*   [Python modules in C](http://dan.iel.fm/posts/python-c-extensions/){:target="_blank"}, Dan Foreman-Mackey;
*   [A Whirlwind Excursion through Python C Extensions](http://nedbatchelder.com/text/whirlext.html){:target="_blank"}, Ned Batchelder.

The rest depends on your C skills. Hello, segmentation fault!

<img alt="The joy of C" src="/assets/media/pyisaac/segfault.jpg">

#### Code

Since, I’m a very fancy guy, I named the package... drum roll... "pyisaac"! The code is available on [GitHub](https://github.com/guilload/pyisaac) under MIT license. I’m far from being a C expert, comments and PR are very welcome. The package is hosted on PyPI and can be installed via `pip` or `easy_install`:

{% highlight sh %}
$ pip install pyisaac
$ easy_install pyisaac
{% endhighlight %}

#### Use

As for the original implementation, the API is dead simple:

{% highlight python %}
>>> import pyisaac
>>> pyisaac.random()
0.3417196273803711
>>> pyisaac.seed('pyisaac')
>>> pyisaac.random()
0.9284197092056274
{% endhighlight %}

#### Implementation

##### Seeding routine

Bob Jenkins provides no official seeding routine for the algorithm. At first, as [suggested](http://www.reddit.com/r/programming/comments/1xl7yc/isaac_a_pseudorandom_number_generator_thats/cfccplq){:target="_blank"} by redditor [BonzaiThePenguin](http://www.reddit.com/user/BonzaiThePenguin){:target="_blank"}, I used 1024 bytes of data from `/dev/random`. Since, this source of randomness is potentially blocking (more about it [here](http://en.wikipedia.org/?title=/dev/random){:target="_blank"} and [there](http://linux.die.net/man/4/random){:target="_blank"}) and not cross-platform, I've decided later on to rely on Python `os.urandom()`. On a UNIX-like system this function will query `/dev/urandom` and on Windows it will use `[CryptGenRandom()](http://en.wikipedia.org/wiki/CryptGenRandom){:target="_blank"}. If no randomness source is found, the algorithm is seeded from the system time and then, **MUST NOT be used for cryptographic purposes**.

##### A story about integers and bytes

I have slightly modified the original file [standard.h](http://burtleburtle.net/bob/c/standard.h){:target="_blank"}. ISAAC relies on 4-byte unsigned integers arithmetic. Back in 1996, unsigned long integers were 4-byte long but nowadays, they are an 8-byte quantity on 64-bit processors. So I replaced them with unsigned integers instead.

##### Mapping integers to floats in [0, 1]

ISAAC generates random integers ranging from 0 to 2<sup>32</sup>-1 (0xFFFFFF), and in theory dividing them by 0xFFFFFF should producting distinct floatting point numbers between 0 and 1. In practice and in computer science particularly, this doesn't work very well.

#### Testing

Bob Jenkins, in his great goodness, provides a seed and the first 2600 random numbers generated from it. pyisaac is tested against these numbers and get them right... but this only means the implementation is right, not that the algorithm generates truly uniformly distributed, unbiased and unpredictable numbers.

In fact, it is impossible to give a mathematical proof that a generator is indeed a random bit generator, as a consequence, generators are submitted to batteries of statistical tests which aim to detect certain kinds of weaknesses such as: 

* shorter than expected periods for some seed states;
* lack of uniformity of distribution for large amounts of generated numbers;
* correlation of successive values, etc.

[Dieharder](http://www.phy.duke.edu/~rgb/General/dieharder.php){:target="_blank"} is an example of such a battery of tests. ISAAC successfully passes all the [Diehard](http://stat.fsu.edu/pub/diehard/){:target="_blank"} and [NIST](http://csrc.nist.gov/groups/ST/toolkit/rng/index.html){:target="_blank"} statistical tests which are part of Dieharder.

#### Performance

Let's get a rough sense of how pyisaac performs compared to `random.random()` from Python's standard library and `numpy.random.rand()`. These PRNGs both implement the [Mersenne twister](http://en.wikipedia.org/wiki/Mersenne_twister){:target="_blank"} algorithm:

<img alt="PRNGs benchmark" src="/assets/media/pyisaac/benchmark.png">

FIXME

and... yes... Python adds much overhead... but let's not start a flame war please, that's not the point of this post :)

That's all folks! I'd like to thank Mike McFadden who gave me [valuable advice](https://github.com/guilload/pyisaac/issues/1){:target="_blank"} on how to seed the generator properly.
